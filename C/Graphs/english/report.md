**Objective:** Implement two of the main graph-related algorithms: Kruskal's algorithm and Dijkstra's algorithm.

## Program Structure

### Kruskal Program

The program consists of five modules:

- `kruskal_main.c`, responsible for executing the program that implements Kruskal's algorithm;
- `grafos.c`, responsible for graph manipulation;
- `grafos.h`, responsible for declaring the functions from `grafos.c` and the structures `node`, `graph`, and `edge`;
- `kruskal.c`, responsible for Kruskal's algorithm;
- `kruskal.h`, responsible for declaring the functions from `kruskal.c` and the `noConj` structure.

### Dijkstra Program

The program consists of five modules:

- `dijkstra_main.c`, responsible for executing the program that implements Dijkstra's algorithm;
- `grafos.c`, responsible for graph manipulation;
- `grafos.h`, responsible for declaring the functions from `grafos.c` and the structures `node`, `graph`, and `edge`;
- `dijkstra.c`, responsible for Dijkstra's algorithm;
- `dijkstra.h`, responsible for declaring the functions from `dijkstra.c`.

### Data Structures Used

### `grafos.c`

```c
struct node {
    int i;
    Peso peso;
    struct node* prox;
};

struct grafo {
    struct node** vViz;
    int nVert;
    int nArest;
};

struct aresta {
    int i;
    int j;
    Peso peso;
};
typedef struct node No;
typedef struct grafo Grafo;
typedef struct aresta Aresta;
```

### `kruskal.c`

```c
struct noConj {
    int chave;
    struct noConj* rep;
};
typedef struct noConj NoConj;
```

### Functions Used

### `grafos.c`

```c
Grafo* criaGrafo(int nVert);
void printaMonografo(Grafo* grafo);
void printaDigrafo(Grafo* grafo);
void printaArestas(Aresta* vArestas, int nArest);
void ordenaArestas(Aresta* vArestas, int nArest);
void adicionaArestaMonografo(Grafo* grafo, Aresta* arestas, int nArest);
void adicionaArestaDigrafo(Grafo* grafo, Aresta* arestas, int nArest);
void liberaGrafo(Grafo* grafo);
```

### `kruskal.c`

```c
void iniciaVertices(NoConj* vVertices, int nVert);
void printaVertices(NoConj* vVertices, int nVert);
void fusion(int num1, int num2, NoConj* vVertices, int nVert);
NoConj* find(int num1, NoConj* vVertices);
Grafo* criaArvMinima(Aresta* vArestas, int nArest, NoConj* vVertices, int nVert);
```

### `dijkstra.c`

```c
void dijkstra(Grafo* grafo, int iOrigem);
```

## Solution

### Kruskal

Initially, the program declares an array of edges, an array of structures of type `NoConj` representing the singletons, two pointer variables to `Grafo`, and two integer variables containing graph information. One of the `Grafo` variables receives the address of the graph generated by `criaGrafo`, and the function `printaMonografo` displays it. After displaying the entire graph, the Kruskal algorithm starts. Initially, the singleton array is initialized, and the edges array is sorted. Then, the `criaArvMinima` function is called. In this function, a graph is initialized by allocating only the array of pointers pointing to the linked lists of each vertex. As the edges array is traversed, for each edge, a `find` is performed on the vertices forming that edge by calling the `find` function. This function operates recursively, looking for the representative of the element. If the representatives of both vertices are different, the `adicionaArestaMonografo` function is called to add a new element to the linked list of the vertex's position. Then, the `fusion` function is called, which considers the height and places the two vertices in the same set. After iterating through all the edges, the graph representing the tree is returned to the second pointer variable to `Grafo`, and `printaMonografo` is called again to display the returned minimum spanning tree. Finally, the memory of both graphs is released using the `liberaGrafo` function.

### Dijkstra

Initially, the graph is constructed based on a predefined set of edges. The graph is displayed before and after the insertions. Then, Dijkstra's algorithm is applied to the graph, with index zero as the source. The function prints a table with the initial conditions (Visit 0), and for each new vertex visit by the algorithm, it updates the Dijkstra table. Naturally, the last printed table contains the minimum distances to the source.

## Observations and Conclusions

Kruskal's and Dijkstra's algorithms were surprisingly easy to implement, especially with the prior development of the `grafos.c` module. Both algorithms functioned correctly and successfully passed all tests. Implementation difficulties were minimal and promptly resolved with the help of a debugger. Finally, the programs were compiled without errors using the Replit development environment, which proved convenient for simultaneous code editing by both group members.
